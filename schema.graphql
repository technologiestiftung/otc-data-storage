### This file was autogenerated by GraphQL Nexus
### Do not make changes to this file directly

type Camera {
  active: Boolean!
  angle: String
  counters(skip: Int): [Counter!]!
  geom: String
  hardware: String
  id: Int!
  lightningConditions(skip: Int): [LightningCondition!]!
  location: String!
  name: String!
  owner: String
  software: String
  softwareHistory: String
  timezone: Int!
  trajectories(skip: Int): [Trajectory!]!
  transformationMatrix: String
  weathers(skip: Int): [Weather!]!
}

input CameraCreateInput {
  active: Boolean!
  angle: String
  counters: CounterCreateManyWithoutCameraInput
  createdAt: DateTime
  geom: String
  hardware: String
  lightningConditions: LightningConditionCreateManyWithoutCameraInput
  location: String!
  name: String!
  owner: String
  software: String
  softwareHistory: String
  timezone: Int!
  trajectories: TrajectoryCreateManyWithoutCameraInput
  transformationMatrix: String
  weathers: WeatherCreateManyWithoutCameraInput
}

input CameraCreateOneWithoutCountersInput {
  connect: CameraWhereUniqueInput
  create: CameraCreateWithoutCountersInput
}

input CameraCreateOneWithoutTrajectoriesInput {
  connect: CameraWhereUniqueInput
  create: CameraCreateWithoutTrajectoriesInput
}

input CameraCreateOneWithoutWeathersInput {
  connect: CameraWhereUniqueInput
  create: CameraCreateWithoutWeathersInput
}

input CameraCreateWithoutCountersInput {
  active: Boolean!
  angle: String
  createdAt: DateTime
  geom: String
  hardware: String
  lightningConditions: LightningConditionCreateManyWithoutCameraInput
  location: String!
  name: String!
  owner: String
  software: String
  softwareHistory: String
  timezone: Int!
  trajectories: TrajectoryCreateManyWithoutCameraInput
  transformationMatrix: String
  weathers: WeatherCreateManyWithoutCameraInput
}

input CameraCreateWithoutTrajectoriesInput {
  active: Boolean!
  angle: String
  counters: CounterCreateManyWithoutCameraInput
  createdAt: DateTime
  geom: String
  hardware: String
  lightningConditions: LightningConditionCreateManyWithoutCameraInput
  location: String!
  name: String!
  owner: String
  software: String
  softwareHistory: String
  timezone: Int!
  transformationMatrix: String
  weathers: WeatherCreateManyWithoutCameraInput
}

input CameraCreateWithoutWeathersInput {
  active: Boolean!
  angle: String
  counters: CounterCreateManyWithoutCameraInput
  createdAt: DateTime
  geom: String
  hardware: String
  lightningConditions: LightningConditionCreateManyWithoutCameraInput
  location: String!
  name: String!
  owner: String
  software: String
  softwareHistory: String
  timezone: Int!
  trajectories: TrajectoryCreateManyWithoutCameraInput
  transformationMatrix: String
}

input CameraWhereUniqueInput {
  id: Int
}

type Counter {
  active: Boolean!
  camera: Camera!
  cameraId: Int!
  detections(skip: Int): [Detection!]!
  direction: String!
  id: Int!
  line: String!
  street: String!
  streetId: String!
  x1: Float!
  x2: Float!
  y1: Float!
  y2: Float!
}

input CounterCreateInput {
  active: Boolean!
  camera: CameraCreateOneWithoutCountersInput!
  createdAt: DateTime
  detections: DetectionCreateManyWithoutCounterInput
  direction: String!
  line: String!
  street: String!
  streetId: String!
  x1: Float!
  x2: Float!
  y1: Float!
  y2: Float!
}

input CounterCreateManyWithoutCameraInput {
  connect: [CounterWhereUniqueInput!]
  create: [CounterCreateWithoutCameraInput!]
}

input CounterCreateOneWithoutDetectionsInput {
  connect: CounterWhereUniqueInput
  create: CounterCreateWithoutDetectionsInput
}

input CounterCreateWithoutCameraInput {
  active: Boolean!
  createdAt: DateTime
  detections: DetectionCreateManyWithoutCounterInput
  direction: String!
  line: String!
  street: String!
  streetId: String!
  x1: Float!
  x2: Float!
  y1: Float!
  y2: Float!
}

input CounterCreateWithoutDetectionsInput {
  active: Boolean!
  camera: CameraCreateOneWithoutCountersInput!
  createdAt: DateTime
  direction: String!
  line: String!
  street: String!
  streetId: String!
  x1: Float!
  x2: Float!
  y1: Float!
  y2: Float!
}

input CounterWhereUniqueInput {
  id: Int
}

scalar DateTime

type Detection {
  accuracy: Float!
  counter: Counter!
  counterId: Int!
  detectedAt: DateTime!
  detectionType: DetectionType!
  detectionTypeId: Int!
  id: Int!
  x: Float!
  y: Float!
}

input DetectionCreateManyWithoutCounterInput {
  connect: [DetectionWhereUniqueInput!]
  create: [DetectionCreateWithoutCounterInput!]
}

input DetectionCreateManyWithoutDetectionTypeInput {
  connect: [DetectionWhereUniqueInput!]
  create: [DetectionCreateWithoutDetectionTypeInput!]
}

input DetectionCreateWithoutCounterInput {
  accuracy: Float!
  createdAt: DateTime
  detectedAt: DateTime!
  detectionType: DetectionTypeCreateOneWithoutDetectionsInput!
  x: Float!
  y: Float!
}

input DetectionCreateWithoutDetectionTypeInput {
  accuracy: Float!
  counter: CounterCreateOneWithoutDetectionsInput!
  createdAt: DateTime
  detectedAt: DateTime!
  x: Float!
  y: Float!
}

type DetectionType {
  description: String
  detections(skip: Int): [Detection!]!
  id: Int!
  label: String!
  trajectories(skip: Int): [Trajectory!]!
}

input DetectionTypeCreateInput {
  description: String
  detections: DetectionCreateManyWithoutDetectionTypeInput
  label: String!
  trajectories: TrajectoryCreateManyWithoutDetectionTypeInput
}

input DetectionTypeCreateOneWithoutDetectionsInput {
  connect: DetectionTypeWhereUniqueInput
  create: DetectionTypeCreateWithoutDetectionsInput
}

input DetectionTypeCreateOneWithoutTrajectoriesInput {
  connect: DetectionTypeWhereUniqueInput
  create: DetectionTypeCreateWithoutTrajectoriesInput
}

input DetectionTypeCreateWithoutDetectionsInput {
  description: String
  label: String!
  trajectories: TrajectoryCreateManyWithoutDetectionTypeInput
}

input DetectionTypeCreateWithoutTrajectoriesInput {
  description: String
  detections: DetectionCreateManyWithoutDetectionTypeInput
  label: String!
}

input DetectionTypeWhereUniqueInput {
  id: Int
}

input DetectionWhereUniqueInput {
  id: Int
}

type LightningCondition {
  camera: Camera!
  cameraId: Int!
  id: Int!
  recordedAt: DateTime!
  value: Float!
}

input LightningConditionCreateManyWithoutCameraInput {
  connect: [LightningConditionWhereUniqueInput!]
  create: [LightningConditionCreateWithoutCameraInput!]
}

input LightningConditionCreateWithoutCameraInput {
  createdAt: DateTime
  recordedAt: DateTime!
  value: Float!
}

input LightningConditionWhereUniqueInput {
  id: Int
}

type Mutation {
  insertCamera(data: CameraCreateInput!): Camera!
  insertCounter(data: CounterCreateInput!): Counter!
  insertDetection(data: CameraCreateInput!): Camera!
  insertDetectionType(data: DetectionTypeCreateInput!): DetectionType!
  insertTrajectory(data: TrajectoryCreateInput!): Trajectory!
  insertWeather(data: WeatherCreateInput!): Weather!
}

type Query {
  """
  Get all cameras. Optionally you can filter by active (boolean) value
  """
  allCameras(
    """
    Filter camera by active value
    """
    active: Boolean
  ): [Camera!]!
  allCounters: [Counter!]!
  allDetections: [Detection!]!
  allDetectionTypes: [DetectionType!]!
  allTrajectories: [Trajectory!]!
  allWeathers: [Weather!]!
  cameraById(where: CameraWhereUniqueInput!): Camera
  counterById(where: CounterWhereUniqueInput!): Counter

  """
  Get all counters from a specific camera
  """
  countersByCameraId(
    """
    The id (Int) of the camera
    """
    cameraId: Int!
  ): [Counter!]!
  detectionById(where: DetectionWhereUniqueInput!): Detection
  detectionTypeById(where: DetectionTypeWhereUniqueInput!): DetectionType
  trajectoryById(where: TrajectoryWhereUniqueInput!): Trajectory
  weatherById(where: WeatherWhereUniqueInput!): Weather
}

type Trajectory {
  camera: Camera!
  cameraId: Int!
  detectionType: DetectionType!
  detectionTypeId: Int!
  end: DateTime!
  geom: String!
  id: Int!
  start: DateTime!
  trajectory: String!
}

input TrajectoryCreateInput {
  camera: CameraCreateOneWithoutTrajectoriesInput!
  detectionType: DetectionTypeCreateOneWithoutTrajectoriesInput!
  end: DateTime!
  geom: String!
  start: DateTime!
  trajectory: String!
}

input TrajectoryCreateManyWithoutCameraInput {
  connect: [TrajectoryWhereUniqueInput!]
  create: [TrajectoryCreateWithoutCameraInput!]
}

input TrajectoryCreateManyWithoutDetectionTypeInput {
  connect: [TrajectoryWhereUniqueInput!]
  create: [TrajectoryCreateWithoutDetectionTypeInput!]
}

input TrajectoryCreateWithoutCameraInput {
  detectionType: DetectionTypeCreateOneWithoutTrajectoriesInput!
  end: DateTime!
  geom: String!
  start: DateTime!
  trajectory: String!
}

input TrajectoryCreateWithoutDetectionTypeInput {
  camera: CameraCreateOneWithoutTrajectoriesInput!
  end: DateTime!
  geom: String!
  start: DateTime!
  trajectory: String!
}

input TrajectoryWhereUniqueInput {
  id: Int
}

type Weather {
  camera: Camera!
  cameraId: Int!
  cloudCoverage: Float
  humidity: Float
  id: Int!
  pressure: Float
  rain: Float
  recordedAt: DateTime!
  temperature: Float
  wind: Float
  windDirection: Float
}

input WeatherCreateInput {
  camera: CameraCreateOneWithoutWeathersInput!
  cloudCoverage: Float
  createdAt: DateTime
  humidity: Float
  pressure: Float
  rain: Float
  recordedAt: DateTime!
  temperature: Float
  wind: Float
  windDirection: Float
}

input WeatherCreateManyWithoutCameraInput {
  connect: [WeatherWhereUniqueInput!]
  create: [WeatherCreateWithoutCameraInput!]
}

input WeatherCreateWithoutCameraInput {
  cloudCoverage: Float
  createdAt: DateTime
  humidity: Float
  pressure: Float
  rain: Float
  recordedAt: DateTime!
  temperature: Float
  wind: Float
  windDirection: Float
}

input WeatherWhereUniqueInput {
  id: Int
}
