### This file was generated by Nexus Schema
### Do not make changes to this file directly


input BooleanFilter {
  equals: Boolean
  not: Boolean
}

type Camera {
  active: Boolean!
  angle: String
  counters(after: CounterWhereUniqueInput, before: CounterWhereUniqueInput, first: Int, last: Int): [Counter!]!
  geom: String
  hardware: String
  id: Int!
  lightningConditions(after: LightningConditionWhereUniqueInput, before: LightningConditionWhereUniqueInput, first: Int, last: Int): [LightningCondition!]!
  location: String!
  name: String!
  owner: String
  software: String
  softwareHistory: String
  timezone: Int!
  trajectories(after: TrajectoryWhereUniqueInput, before: TrajectoryWhereUniqueInput, first: Int, last: Int): [Trajectory!]!
  transformationMatrix: String
  weathers(after: WeatherWhereUniqueInput, before: WeatherWhereUniqueInput, first: Int, last: Int): [Weather!]!
}

input CameraCreateInput {
  active: Boolean!
  angle: String
  counters: CounterCreateManyWithoutCameraInput
  createdAt: DateTime
  geom: String
  hardware: String
  lightningConditions: LightningConditionCreateManyWithoutCameraInput
  location: String!
  name: String!
  owner: String
  software: String
  softwareHistory: String
  timezone: Int!
  trajectories: TrajectoryCreateManyWithoutCameraInput
  transformationMatrix: String
  weathers: WeatherCreateManyWithoutCameraInput
}

input CameraCreateOneWithoutCountersInput {
  connect: CameraWhereUniqueInput
  create: CameraCreateWithoutCountersInput
}

input CameraCreateOneWithoutTrajectoriesInput {
  connect: CameraWhereUniqueInput
  create: CameraCreateWithoutTrajectoriesInput
}

input CameraCreateOneWithoutWeathersInput {
  connect: CameraWhereUniqueInput
  create: CameraCreateWithoutWeathersInput
}

input CameraCreateWithoutCountersInput {
  active: Boolean!
  angle: String
  createdAt: DateTime
  geom: String
  hardware: String
  lightningConditions: LightningConditionCreateManyWithoutCameraInput
  location: String!
  name: String!
  owner: String
  software: String
  softwareHistory: String
  timezone: Int!
  trajectories: TrajectoryCreateManyWithoutCameraInput
  transformationMatrix: String
  weathers: WeatherCreateManyWithoutCameraInput
}

input CameraCreateWithoutTrajectoriesInput {
  active: Boolean!
  angle: String
  counters: CounterCreateManyWithoutCameraInput
  createdAt: DateTime
  geom: String
  hardware: String
  lightningConditions: LightningConditionCreateManyWithoutCameraInput
  location: String!
  name: String!
  owner: String
  software: String
  softwareHistory: String
  timezone: Int!
  transformationMatrix: String
  weathers: WeatherCreateManyWithoutCameraInput
}

input CameraCreateWithoutWeathersInput {
  active: Boolean!
  angle: String
  counters: CounterCreateManyWithoutCameraInput
  createdAt: DateTime
  geom: String
  hardware: String
  lightningConditions: LightningConditionCreateManyWithoutCameraInput
  location: String!
  name: String!
  owner: String
  software: String
  softwareHistory: String
  timezone: Int!
  trajectories: TrajectoryCreateManyWithoutCameraInput
  transformationMatrix: String
}

input CameraOrderByInput {
  active: OrderByArg
  angle: OrderByArg
  createdAt: OrderByArg
  geom: OrderByArg
  hardware: OrderByArg
  id: OrderByArg
  location: OrderByArg
  name: OrderByArg
  owner: OrderByArg
  software: OrderByArg
  softwareHistory: OrderByArg
  timezone: OrderByArg
  transformationMatrix: OrderByArg
}

input CameraWhereInput {
  active: BooleanFilter
  AND: [CameraWhereInput!]
  angle: NullableStringFilter
  counters: CounterFilter
  createdAt: DateTimeFilter
  geom: NullableStringFilter
  hardware: NullableStringFilter
  id: IntFilter
  lightningConditions: LightningConditionFilter
  location: StringFilter
  name: StringFilter
  NOT: [CameraWhereInput!]
  OR: [CameraWhereInput!]
  owner: NullableStringFilter
  software: NullableStringFilter
  softwareHistory: NullableStringFilter
  timezone: IntFilter
  trajectories: TrajectoryFilter
  transformationMatrix: NullableStringFilter
  weathers: WeatherFilter
}

input CameraWhereUniqueInput {
  id: Int
}

type Counter {
  active: Boolean!
  camera: Camera!
  cameraId: Int!
  detections(after: DetectionWhereUniqueInput, before: DetectionWhereUniqueInput, first: Int, last: Int): [Detection!]!
  direction: String!
  id: Int!
  line: String!
  street: String!
  streetId: String!
  x1: Float!
  x2: Float!
  y1: Float!
  y2: Float!
}

input CounterCreateInput {
  active: Boolean!
  camera: CameraCreateOneWithoutCountersInput!
  createdAt: DateTime
  detections: DetectionCreateManyWithoutCounterInput
  direction: String!
  line: String!
  street: String!
  streetId: String!
  x1: Float!
  x2: Float!
  y1: Float!
  y2: Float!
}

input CounterCreateManyWithoutCameraInput {
  connect: [CounterWhereUniqueInput!]
  create: [CounterCreateWithoutCameraInput!]
}

input CounterCreateOneWithoutDetectionsInput {
  connect: CounterWhereUniqueInput
  create: CounterCreateWithoutDetectionsInput
}

input CounterCreateWithoutCameraInput {
  active: Boolean!
  createdAt: DateTime
  detections: DetectionCreateManyWithoutCounterInput
  direction: String!
  line: String!
  street: String!
  streetId: String!
  x1: Float!
  x2: Float!
  y1: Float!
  y2: Float!
}

input CounterCreateWithoutDetectionsInput {
  active: Boolean!
  camera: CameraCreateOneWithoutCountersInput!
  createdAt: DateTime
  direction: String!
  line: String!
  street: String!
  streetId: String!
  x1: Float!
  x2: Float!
  y1: Float!
  y2: Float!
}

input CounterFilter {
  every: CounterWhereInput
  none: CounterWhereInput
  some: CounterWhereInput
}

input CounterOrderByInput {
  active: OrderByArg
  cameraId: OrderByArg
  createdAt: OrderByArg
  direction: OrderByArg
  id: OrderByArg
  line: OrderByArg
  street: OrderByArg
  streetId: OrderByArg
  x1: OrderByArg
  x2: OrderByArg
  y1: OrderByArg
  y2: OrderByArg
}

input CounterWhereInput {
  active: BooleanFilter
  AND: [CounterWhereInput!]
  camera: CameraWhereInput
  cameraId: IntFilter
  createdAt: DateTimeFilter
  detections: DetectionFilter
  direction: StringFilter
  id: IntFilter
  line: StringFilter
  NOT: [CounterWhereInput!]
  OR: [CounterWhereInput!]
  street: StringFilter
  streetId: StringFilter
  x1: FloatFilter
  x2: FloatFilter
  y1: FloatFilter
  y2: FloatFilter
}

input CounterWhereUniqueInput {
  id: Int
}

"""Use JavaScript Date object for date/time fields."""
scalar DateTime

input DateTimeFilter {
  equals: DateTime
  gt: DateTime
  gte: DateTime
  in: [DateTime!]
  lt: DateTime
  lte: DateTime
  not: DateTime
  notIn: [DateTime!]
}

type Detection {
  accuracy: Float!
  counter: Counter!
  counterId: Int!
  detectedAt: DateTime!
  detectionType: DetectionType!
  detectionTypeId: Int!
  id: Int!
  x: Float!
  y: Float!
}

input DetectionCreateManyWithoutCounterInput {
  connect: [DetectionWhereUniqueInput!]
  create: [DetectionCreateWithoutCounterInput!]
}

input DetectionCreateManyWithoutDetectionTypeInput {
  connect: [DetectionWhereUniqueInput!]
  create: [DetectionCreateWithoutDetectionTypeInput!]
}

input DetectionCreateWithoutCounterInput {
  accuracy: Float!
  createdAt: DateTime
  detectedAt: DateTime!
  detectionType: DetectionTypeCreateOneWithoutDetectionsInput!
  x: Float!
  y: Float!
}

input DetectionCreateWithoutDetectionTypeInput {
  accuracy: Float!
  counter: CounterCreateOneWithoutDetectionsInput!
  createdAt: DateTime
  detectedAt: DateTime!
  x: Float!
  y: Float!
}

input DetectionFilter {
  every: DetectionWhereInput
  none: DetectionWhereInput
  some: DetectionWhereInput
}

input DetectionOrderByInput {
  accuracy: OrderByArg
  counterId: OrderByArg
  createdAt: OrderByArg
  detectedAt: OrderByArg
  detectionTypeId: OrderByArg
  id: OrderByArg
  x: OrderByArg
  y: OrderByArg
}

type DetectionType {
  description: String
  detections(after: DetectionWhereUniqueInput, before: DetectionWhereUniqueInput, first: Int, last: Int): [Detection!]!
  id: Int!
  label: String!
  trajectories(after: TrajectoryWhereUniqueInput, before: TrajectoryWhereUniqueInput, first: Int, last: Int): [Trajectory!]!
}

input DetectionTypeCreateInput {
  description: String
  detections: DetectionCreateManyWithoutDetectionTypeInput
  label: String!
  trajectories: TrajectoryCreateManyWithoutDetectionTypeInput
}

input DetectionTypeCreateOneWithoutDetectionsInput {
  connect: DetectionTypeWhereUniqueInput
  create: DetectionTypeCreateWithoutDetectionsInput
}

input DetectionTypeCreateOneWithoutTrajectoriesInput {
  connect: DetectionTypeWhereUniqueInput
  create: DetectionTypeCreateWithoutTrajectoriesInput
}

input DetectionTypeCreateWithoutDetectionsInput {
  description: String
  label: String!
  trajectories: TrajectoryCreateManyWithoutDetectionTypeInput
}

input DetectionTypeCreateWithoutTrajectoriesInput {
  description: String
  detections: DetectionCreateManyWithoutDetectionTypeInput
  label: String!
}

input DetectionTypeOrderByInput {
  description: OrderByArg
  id: OrderByArg
  label: OrderByArg
}

input DetectionTypeWhereInput {
  AND: [DetectionTypeWhereInput!]
  description: NullableStringFilter
  detections: DetectionFilter
  id: IntFilter
  label: StringFilter
  NOT: [DetectionTypeWhereInput!]
  OR: [DetectionTypeWhereInput!]
  trajectories: TrajectoryFilter
}

input DetectionTypeWhereUniqueInput {
  id: Int
}

input DetectionWhereInput {
  accuracy: FloatFilter
  AND: [DetectionWhereInput!]
  counter: CounterWhereInput
  counterId: IntFilter
  createdAt: DateTimeFilter
  detectedAt: DateTimeFilter
  detectionType: DetectionTypeWhereInput
  detectionTypeId: IntFilter
  id: IntFilter
  NOT: [DetectionWhereInput!]
  OR: [DetectionWhereInput!]
  x: FloatFilter
  y: FloatFilter
}

input DetectionWhereUniqueInput {
  id: Int
}

input FloatFilter {
  equals: Float
  gt: Float
  gte: Float
  in: [Float!]
  lt: Float
  lte: Float
  not: Float
  notIn: [Float!]
}

input IntFilter {
  equals: Int
  gt: Int
  gte: Int
  in: [Int!]
  lt: Int
  lte: Int
  not: Int
  notIn: [Int!]
}

"""
The `JSON` scalar type represents JSON objects as specified by [ECMA-404](http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-404.pdf).
"""
scalar Json

type LightningCondition {
  camera: Camera!
  cameraId: Int!
  id: Int!
  recordedAt: DateTime!
  value: Float!
}

input LightningConditionCreateManyWithoutCameraInput {
  connect: [LightningConditionWhereUniqueInput!]
  create: [LightningConditionCreateWithoutCameraInput!]
}

input LightningConditionCreateWithoutCameraInput {
  createdAt: DateTime
  recordedAt: DateTime!
  value: Float!
}

input LightningConditionFilter {
  every: LightningConditionWhereInput
  none: LightningConditionWhereInput
  some: LightningConditionWhereInput
}

input LightningConditionOrderByInput {
  cameraId: OrderByArg
  createdAt: OrderByArg
  id: OrderByArg
  recordedAt: OrderByArg
  value: OrderByArg
}

input LightningConditionWhereInput {
  AND: [LightningConditionWhereInput!]
  camera: CameraWhereInput
  cameraId: IntFilter
  createdAt: DateTimeFilter
  id: IntFilter
  NOT: [LightningConditionWhereInput!]
  OR: [LightningConditionWhereInput!]
  recordedAt: DateTimeFilter
  value: FloatFilter
}

input LightningConditionWhereUniqueInput {
  id: Int
}

type Mutation {
  insertCamera(data: CameraCreateInput!): Camera!
  insertCounter(data: CounterCreateInput!): Counter!
  insertDetection(data: CameraCreateInput!): Camera!
  insertDetectionType(data: DetectionTypeCreateInput!): DetectionType!
  insertTrajectory(data: TrajectoryCreateInput!): Trajectory!
  insertWeather(data: WeatherCreateInput!): Weather!
}

input NullableFloatFilter {
  equals: Float
  gt: Float
  gte: Float
  in: [Float!]
  lt: Float
  lte: Float
  not: Float
  notIn: [Float!]
}

input NullableStringFilter {
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  not: String
  notIn: [String!]
  startsWith: String
}

enum OrderByArg {
  asc
  desc
}

type Query {
  """Get all cameras. Optionally you can filter by active (boolean) value"""
  allCameraByActivity(
    """Filter camera by active value"""
    active: Boolean
  ): [Camera!]
  allCameras(after: CameraWhereUniqueInput, before: CameraWhereUniqueInput, first: Int, last: Int, orderBy: CameraOrderByInput, where: CameraWhereInput): [Camera!]!
  allCounters(after: CounterWhereUniqueInput, before: CounterWhereUniqueInput, first: Int, last: Int, orderBy: CounterOrderByInput, where: CounterWhereInput): [Counter!]!
  allDetections(after: DetectionWhereUniqueInput, before: DetectionWhereUniqueInput, first: Int, last: Int, orderBy: DetectionOrderByInput, where: DetectionWhereInput): [Detection!]!
  allDetectionTypes(after: DetectionTypeWhereUniqueInput, before: DetectionTypeWhereUniqueInput, first: Int, last: Int, orderBy: DetectionTypeOrderByInput, where: DetectionTypeWhereInput): [DetectionType!]!
  allLightingConditions(after: LightningConditionWhereUniqueInput, before: LightningConditionWhereUniqueInput, first: Int, last: Int, orderBy: LightningConditionOrderByInput, where: LightningConditionWhereInput): [LightningCondition!]!
  allTrajectories(after: TrajectoryWhereUniqueInput, before: TrajectoryWhereUniqueInput, first: Int, last: Int, orderBy: TrajectoryOrderByInput, where: TrajectoryWhereInput): [Trajectory!]!
  allWeathers(after: WeatherWhereUniqueInput, before: WeatherWhereUniqueInput, first: Int, last: Int, orderBy: WeatherOrderByInput, where: WeatherWhereInput): [Weather!]!
  cameraById(where: CameraWhereUniqueInput!): Camera
  counterById(where: CounterWhereUniqueInput!): Counter

  """Get all counters from a specific camera"""
  countersByCameraId(
    """The id (Int) of the camera"""
    cameraId: Int!
  ): [Counter!]
  detectionById(where: DetectionWhereUniqueInput!): Detection
  detectionTypeById(where: DetectionTypeWhereUniqueInput!): DetectionType
  lightningConditionById(where: LightningConditionWhereUniqueInput!): LightningCondition
  trajectoryById(where: TrajectoryWhereUniqueInput!): Trajectory
  weatherById(where: WeatherWhereUniqueInput!): Weather
}

input StringFilter {
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  not: String
  notIn: [String!]
  startsWith: String
}

type Trajectory {
  camera: Camera!
  cameraId: Int!
  detectionType: DetectionType!
  detectionTypeId: Int!
  end: DateTime!
  geom: String!
  id: Int!
  start: DateTime!
  trajectory: String!
}

input TrajectoryCreateInput {
  camera: CameraCreateOneWithoutTrajectoriesInput!
  detectionType: DetectionTypeCreateOneWithoutTrajectoriesInput!
  end: DateTime!
  geom: String!
  start: DateTime!
  trajectory: String!
}

input TrajectoryCreateManyWithoutCameraInput {
  connect: [TrajectoryWhereUniqueInput!]
  create: [TrajectoryCreateWithoutCameraInput!]
}

input TrajectoryCreateManyWithoutDetectionTypeInput {
  connect: [TrajectoryWhereUniqueInput!]
  create: [TrajectoryCreateWithoutDetectionTypeInput!]
}

input TrajectoryCreateWithoutCameraInput {
  detectionType: DetectionTypeCreateOneWithoutTrajectoriesInput!
  end: DateTime!
  geom: String!
  start: DateTime!
  trajectory: String!
}

input TrajectoryCreateWithoutDetectionTypeInput {
  camera: CameraCreateOneWithoutTrajectoriesInput!
  end: DateTime!
  geom: String!
  start: DateTime!
  trajectory: String!
}

input TrajectoryFilter {
  every: TrajectoryWhereInput
  none: TrajectoryWhereInput
  some: TrajectoryWhereInput
}

input TrajectoryOrderByInput {
  cameraId: OrderByArg
  detectionTypeId: OrderByArg
  end: OrderByArg
  geom: OrderByArg
  id: OrderByArg
  start: OrderByArg
  trajectory: OrderByArg
}

input TrajectoryWhereInput {
  AND: [TrajectoryWhereInput!]
  camera: CameraWhereInput
  cameraId: IntFilter
  detectionType: DetectionTypeWhereInput
  detectionTypeId: IntFilter
  end: DateTimeFilter
  geom: StringFilter
  id: IntFilter
  NOT: [TrajectoryWhereInput!]
  OR: [TrajectoryWhereInput!]
  start: DateTimeFilter
  trajectory: StringFilter
}

input TrajectoryWhereUniqueInput {
  id: Int
}

type Weather {
  camera: Camera!
  cameraId: Int!
  cloudCoverage: Float
  humidity: Float
  id: Int!
  pressure: Float
  rain: Float
  recordedAt: DateTime!
  temperature: Float
  wind: Float
  windDirection: Float
}

input WeatherCreateInput {
  camera: CameraCreateOneWithoutWeathersInput!
  cloudCoverage: Float
  createdAt: DateTime
  humidity: Float
  pressure: Float
  rain: Float
  recordedAt: DateTime!
  temperature: Float
  wind: Float
  windDirection: Float
}

input WeatherCreateManyWithoutCameraInput {
  connect: [WeatherWhereUniqueInput!]
  create: [WeatherCreateWithoutCameraInput!]
}

input WeatherCreateWithoutCameraInput {
  cloudCoverage: Float
  createdAt: DateTime
  humidity: Float
  pressure: Float
  rain: Float
  recordedAt: DateTime!
  temperature: Float
  wind: Float
  windDirection: Float
}

input WeatherFilter {
  every: WeatherWhereInput
  none: WeatherWhereInput
  some: WeatherWhereInput
}

input WeatherOrderByInput {
  cameraId: OrderByArg
  cloudCoverage: OrderByArg
  createdAt: OrderByArg
  humidity: OrderByArg
  id: OrderByArg
  pressure: OrderByArg
  rain: OrderByArg
  recordedAt: OrderByArg
  temperature: OrderByArg
  wind: OrderByArg
  windDirection: OrderByArg
}

input WeatherWhereInput {
  AND: [WeatherWhereInput!]
  camera: CameraWhereInput
  cameraId: IntFilter
  cloudCoverage: NullableFloatFilter
  createdAt: DateTimeFilter
  humidity: NullableFloatFilter
  id: IntFilter
  NOT: [WeatherWhereInput!]
  OR: [WeatherWhereInput!]
  pressure: NullableFloatFilter
  rain: NullableFloatFilter
  recordedAt: DateTimeFilter
  temperature: NullableFloatFilter
  wind: NullableFloatFilter
  windDirection: NullableFloatFilter
}

input WeatherWhereUniqueInput {
  id: Int
}
