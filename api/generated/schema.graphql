### This file was generated by Nexus Schema
### Do not make changes to this file directly

type AuthPayload {
  token: String
  user: User
}

input BoolFilter {
  equals: Boolean
  not: NestedBoolFilter
}

type Camera {
  active: Boolean!
  angle: String
  counters(
    after: CounterWhereUniqueInput
    before: CounterWhereUniqueInput
    first: Int
    last: Int
  ): [Counter!]!
  geom: String
  hardware: String
  id: Int!
  lightningConditions(
    after: LightningConditionWhereUniqueInput
    before: LightningConditionWhereUniqueInput
    first: Int
    last: Int
  ): [LightningCondition!]!
  location: String!
  name: String!
  owner: String
  software: String
  softwareHistory: String
  timezone: Int!
  trajectories(
    after: TrajectoryWhereUniqueInput
    before: TrajectoryWhereUniqueInput
    first: Int
    last: Int
  ): [Trajectory!]!
  transformationMatrix: String
  weathers(
    after: WeatherWhereUniqueInput
    before: WeatherWhereUniqueInput
    first: Int
    last: Int
  ): [Weather!]!
}

input CameraCreateInput {
  active: Boolean!
  angle: String
  counters: CounterCreateManyWithoutCameraInput
  createdAt: DateTime
  geom: String
  hardware: String
  lightningConditions: LightningConditionCreateManyWithoutCameraInput
  location: String!
  name: String!
  owner: String
  software: String
  softwareHistory: String
  timezone: Int!
  trajectories: TrajectoryCreateManyWithoutCameraInput
  transformationMatrix: String
  weathers: WeatherCreateManyWithoutCameraInput
}

input CameraCreateOneWithoutCountersInput {
  connect: CameraWhereUniqueInput
  create: CameraCreateWithoutCountersInput
}

input CameraCreateOneWithoutTrajectoriesInput {
  connect: CameraWhereUniqueInput
  create: CameraCreateWithoutTrajectoriesInput
}

input CameraCreateOneWithoutWeathersInput {
  connect: CameraWhereUniqueInput
  create: CameraCreateWithoutWeathersInput
}

input CameraCreateWithoutCountersInput {
  active: Boolean!
  angle: String
  createdAt: DateTime
  geom: String
  hardware: String
  lightningConditions: LightningConditionCreateManyWithoutCameraInput
  location: String!
  name: String!
  owner: String
  software: String
  softwareHistory: String
  timezone: Int!
  trajectories: TrajectoryCreateManyWithoutCameraInput
  transformationMatrix: String
  weathers: WeatherCreateManyWithoutCameraInput
}

input CameraCreateWithoutTrajectoriesInput {
  active: Boolean!
  angle: String
  counters: CounterCreateManyWithoutCameraInput
  createdAt: DateTime
  geom: String
  hardware: String
  lightningConditions: LightningConditionCreateManyWithoutCameraInput
  location: String!
  name: String!
  owner: String
  software: String
  softwareHistory: String
  timezone: Int!
  transformationMatrix: String
  weathers: WeatherCreateManyWithoutCameraInput
}

input CameraCreateWithoutWeathersInput {
  active: Boolean!
  angle: String
  counters: CounterCreateManyWithoutCameraInput
  createdAt: DateTime
  geom: String
  hardware: String
  lightningConditions: LightningConditionCreateManyWithoutCameraInput
  location: String!
  name: String!
  owner: String
  software: String
  softwareHistory: String
  timezone: Int!
  trajectories: TrajectoryCreateManyWithoutCameraInput
  transformationMatrix: String
}

input CameraOrderByInput {
  active: SortOrder
  angle: SortOrder
  createdAt: SortOrder
  geom: SortOrder
  hardware: SortOrder
  id: SortOrder
  location: SortOrder
  name: SortOrder
  owner: SortOrder
  software: SortOrder
  softwareHistory: SortOrder
  timezone: SortOrder
  transformationMatrix: SortOrder
}

input CameraWhereInput {
  active: BoolFilter
  AND: [CameraWhereInput!]
  angle: StringNullableFilter
  counters: CounterListRelationFilter
  createdAt: DateTimeFilter
  geom: StringNullableFilter
  hardware: StringNullableFilter
  id: IntFilter
  lightningConditions: LightningConditionListRelationFilter
  location: StringFilter
  name: StringFilter
  NOT: [CameraWhereInput!]
  OR: [CameraWhereInput!]
  owner: StringNullableFilter
  software: StringNullableFilter
  softwareHistory: StringNullableFilter
  timezone: IntFilter
  trajectories: TrajectoryListRelationFilter
  transformationMatrix: StringNullableFilter
  weathers: WeatherListRelationFilter
}

input CameraWhereUniqueInput {
  id: Int
}

type Counter {
  active: Boolean!
  camera: Camera!
  cameraId: Int!
  detections(
    after: DetectionWhereUniqueInput
    before: DetectionWhereUniqueInput
    first: Int
    last: Int
  ): [Detection!]!
  direction: String!
  id: Int!
  line: String!
  street: String!
  streetId: String!
  x1: Float!
  x2: Float!
  y1: Float!
  y2: Float!
}

input CounterCreateInput {
  active: Boolean!
  camera: CameraCreateOneWithoutCountersInput!
  createdAt: DateTime
  detections: DetectionCreateManyWithoutCounterInput
  direction: String!
  line: String!
  street: String!
  streetId: String!
  x1: Float!
  x2: Float!
  y1: Float!
  y2: Float!
}

input CounterCreateManyWithoutCameraInput {
  connect: [CounterWhereUniqueInput!]
  create: [CounterCreateWithoutCameraInput!]
}

input CounterCreateOneWithoutDetectionsInput {
  connect: CounterWhereUniqueInput
  create: CounterCreateWithoutDetectionsInput
}

input CounterCreateWithoutCameraInput {
  active: Boolean!
  createdAt: DateTime
  detections: DetectionCreateManyWithoutCounterInput
  direction: String!
  line: String!
  street: String!
  streetId: String!
  x1: Float!
  x2: Float!
  y1: Float!
  y2: Float!
}

input CounterCreateWithoutDetectionsInput {
  active: Boolean!
  camera: CameraCreateOneWithoutCountersInput!
  createdAt: DateTime
  direction: String!
  line: String!
  street: String!
  streetId: String!
  x1: Float!
  x2: Float!
  y1: Float!
  y2: Float!
}

input CounterListRelationFilter {
  every: CounterWhereInput
  none: CounterWhereInput
  some: CounterWhereInput
}

input CounterOrderByInput {
  active: SortOrder
  cameraId: SortOrder
  createdAt: SortOrder
  direction: SortOrder
  id: SortOrder
  line: SortOrder
  street: SortOrder
  streetId: SortOrder
  x1: SortOrder
  x2: SortOrder
  y1: SortOrder
  y2: SortOrder
}

input CounterWhereInput {
  active: BoolFilter
  AND: [CounterWhereInput!]
  camera: CameraWhereInput
  cameraId: IntFilter
  createdAt: DateTimeFilter
  detections: DetectionListRelationFilter
  direction: StringFilter
  id: IntFilter
  line: StringFilter
  NOT: [CounterWhereInput!]
  OR: [CounterWhereInput!]
  street: StringFilter
  streetId: StringFilter
  x1: FloatFilter
  x2: FloatFilter
  y1: FloatFilter
  y2: FloatFilter
}

input CounterWhereUniqueInput {
  id: Int
}

"""
A date-time string at UTC, such as 2007-12-03T10:15:30Z, compliant with the
`date-time` format outlined in section 5.6 of the RFC 3339 profile of the ISO
8601 standard for representation of dates and times using the Gregorian calendar.
"""
scalar DateTime

input DateTimeFilter {
  equals: DateTime
  gt: DateTime
  gte: DateTime
  in: [DateTime!]
  lt: DateTime
  lte: DateTime
  not: NestedDateTimeFilter
  notIn: [DateTime!]
}

type Detection {
  accuracy: Float!
  counter: Counter!
  counterId: Int!
  detectedAt: DateTime!
  detectionType: DetectionType!
  detectionTypeId: Int!
  id: Int!
  x: Float!
  y: Float!
}

input DetectionCreateManyWithoutCounterInput {
  connect: [DetectionWhereUniqueInput!]
  create: [DetectionCreateWithoutCounterInput!]
}

input DetectionCreateManyWithoutDetectionTypeInput {
  connect: [DetectionWhereUniqueInput!]
  create: [DetectionCreateWithoutDetectionTypeInput!]
}

input DetectionCreateWithoutCounterInput {
  accuracy: Float!
  createdAt: DateTime
  detectedAt: DateTime!
  detectionType: DetectionTypeCreateOneWithoutDetectionsInput!
  x: Float!
  y: Float!
}

input DetectionCreateWithoutDetectionTypeInput {
  accuracy: Float!
  counter: CounterCreateOneWithoutDetectionsInput!
  createdAt: DateTime
  detectedAt: DateTime!
  x: Float!
  y: Float!
}

input DetectionListRelationFilter {
  every: DetectionWhereInput
  none: DetectionWhereInput
  some: DetectionWhereInput
}

input DetectionOrderByInput {
  accuracy: SortOrder
  counterId: SortOrder
  createdAt: SortOrder
  detectedAt: SortOrder
  detectionTypeId: SortOrder
  id: SortOrder
  x: SortOrder
  y: SortOrder
}

type DetectionType {
  description: String
  detections(
    after: DetectionWhereUniqueInput
    before: DetectionWhereUniqueInput
    first: Int
    last: Int
  ): [Detection!]!
  id: Int!
  label: String!
  trajectories(
    after: TrajectoryWhereUniqueInput
    before: TrajectoryWhereUniqueInput
    first: Int
    last: Int
  ): [Trajectory!]!
}

input DetectionTypeCreateInput {
  description: String
  detections: DetectionCreateManyWithoutDetectionTypeInput
  label: String!
  trajectories: TrajectoryCreateManyWithoutDetectionTypeInput
}

input DetectionTypeCreateOneWithoutDetectionsInput {
  connect: DetectionTypeWhereUniqueInput
  create: DetectionTypeCreateWithoutDetectionsInput
}

input DetectionTypeCreateOneWithoutTrajectoriesInput {
  connect: DetectionTypeWhereUniqueInput
  create: DetectionTypeCreateWithoutTrajectoriesInput
}

input DetectionTypeCreateWithoutDetectionsInput {
  description: String
  label: String!
  trajectories: TrajectoryCreateManyWithoutDetectionTypeInput
}

input DetectionTypeCreateWithoutTrajectoriesInput {
  description: String
  detections: DetectionCreateManyWithoutDetectionTypeInput
  label: String!
}

input DetectionTypeOrderByInput {
  description: SortOrder
  id: SortOrder
  label: SortOrder
}

input DetectionTypeWhereInput {
  AND: [DetectionTypeWhereInput!]
  description: StringNullableFilter
  detections: DetectionListRelationFilter
  id: IntFilter
  label: StringFilter
  NOT: [DetectionTypeWhereInput!]
  OR: [DetectionTypeWhereInput!]
  trajectories: TrajectoryListRelationFilter
}

input DetectionTypeWhereUniqueInput {
  id: Int
}

input DetectionWhereInput {
  accuracy: FloatFilter
  AND: [DetectionWhereInput!]
  counter: CounterWhereInput
  counterId: IntFilter
  createdAt: DateTimeFilter
  detectedAt: DateTimeFilter
  detectionType: DetectionTypeWhereInput
  detectionTypeId: IntFilter
  id: IntFilter
  NOT: [DetectionWhereInput!]
  OR: [DetectionWhereInput!]
  x: FloatFilter
  y: FloatFilter
}

input DetectionWhereUniqueInput {
  id: Int
}

input FloatFilter {
  equals: Float
  gt: Float
  gte: Float
  in: [Float!]
  lt: Float
  lte: Float
  not: NestedFloatFilter
  notIn: [Float!]
}

input FloatNullableFilter {
  equals: Float
  gt: Float
  gte: Float
  in: [Float!]
  lt: Float
  lte: Float
  not: NestedFloatNullableFilter
  notIn: [Float!]
}

input IntFilter {
  equals: Int
  gt: Int
  gte: Int
  in: [Int!]
  lt: Int
  lte: Int
  not: NestedIntFilter
  notIn: [Int!]
}

"""
The `JSON` scalar type represents JSON objects as specified by [ECMA-404](http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-404.pdf).
"""
scalar Json

type LightningCondition {
  camera: Camera!
  cameraId: Int!
  id: Int!
  recordedAt: DateTime!
  value: Float!
}

input LightningConditionCreateManyWithoutCameraInput {
  connect: [LightningConditionWhereUniqueInput!]
  create: [LightningConditionCreateWithoutCameraInput!]
}

input LightningConditionCreateWithoutCameraInput {
  createdAt: DateTime
  recordedAt: DateTime!
  value: Float!
}

input LightningConditionListRelationFilter {
  every: LightningConditionWhereInput
  none: LightningConditionWhereInput
  some: LightningConditionWhereInput
}

input LightningConditionOrderByInput {
  cameraId: SortOrder
  createdAt: SortOrder
  id: SortOrder
  recordedAt: SortOrder
  value: SortOrder
}

input LightningConditionWhereInput {
  AND: [LightningConditionWhereInput!]
  camera: CameraWhereInput
  cameraId: IntFilter
  createdAt: DateTimeFilter
  id: IntFilter
  NOT: [LightningConditionWhereInput!]
  OR: [LightningConditionWhereInput!]
  recordedAt: DateTimeFilter
  value: FloatFilter
}

input LightningConditionWhereUniqueInput {
  id: Int
}

type Mutation {
  insertCamera(data: CameraCreateInput!): Camera!
  insertCounter(data: CounterCreateInput!): Counter!
  insertDetection(data: CameraCreateInput!): Camera!
  insertDetectionType(data: DetectionTypeCreateInput!): DetectionType!
  insertTrajectory(data: TrajectoryCreateInput!): Trajectory!
  insertWeather(data: WeatherCreateInput!): Weather!
  login(email: String!, password: String!): AuthPayload
  signup(email: String!, name: String, password: String!): AuthPayload
}

input NestedBoolFilter {
  equals: Boolean
  not: NestedBoolFilter
}

input NestedDateTimeFilter {
  equals: DateTime
  gt: DateTime
  gte: DateTime
  in: [DateTime!]
  lt: DateTime
  lte: DateTime
  not: NestedDateTimeFilter
  notIn: [DateTime!]
}

input NestedFloatFilter {
  equals: Float
  gt: Float
  gte: Float
  in: [Float!]
  lt: Float
  lte: Float
  not: NestedFloatFilter
  notIn: [Float!]
}

input NestedFloatNullableFilter {
  equals: Float
  gt: Float
  gte: Float
  in: [Float!]
  lt: Float
  lte: Float
  not: NestedFloatNullableFilter
  notIn: [Float!]
}

input NestedIntFilter {
  equals: Int
  gt: Int
  gte: Int
  in: [Int!]
  lt: Int
  lte: Int
  not: NestedIntFilter
  notIn: [Int!]
}

input NestedStringFilter {
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  not: NestedStringFilter
  notIn: [String!]
  startsWith: String
}

input NestedStringNullableFilter {
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  not: NestedStringNullableFilter
  notIn: [String!]
  startsWith: String
}

type Query {
  """
  Get all cameras. Optionally you can filter by active (boolean) value
  """
  allCameraByActivity(
    """
    Filter camera by active value
    """
    active: Boolean
  ): [Camera!]
  allCameras(
    after: CameraWhereUniqueInput
    before: CameraWhereUniqueInput
    first: Int
    last: Int
    orderBy: [CameraOrderByInput!]
    where: CameraWhereInput
  ): [Camera!]!
  allCounters(
    after: CounterWhereUniqueInput
    before: CounterWhereUniqueInput
    first: Int
    last: Int
    orderBy: [CounterOrderByInput!]
    where: CounterWhereInput
  ): [Counter!]!
  allDetections(
    after: DetectionWhereUniqueInput
    before: DetectionWhereUniqueInput
    first: Int
    last: Int
    orderBy: [DetectionOrderByInput!]
    where: DetectionWhereInput
  ): [Detection!]!
  allDetectionTypes(
    after: DetectionTypeWhereUniqueInput
    before: DetectionTypeWhereUniqueInput
    first: Int
    last: Int
    orderBy: [DetectionTypeOrderByInput!]
    where: DetectionTypeWhereInput
  ): [DetectionType!]!
  allLightingConditions(
    after: LightningConditionWhereUniqueInput
    before: LightningConditionWhereUniqueInput
    first: Int
    last: Int
    orderBy: [LightningConditionOrderByInput!]
    where: LightningConditionWhereInput
  ): [LightningCondition!]!
  allTrajectories(
    after: TrajectoryWhereUniqueInput
    before: TrajectoryWhereUniqueInput
    first: Int
    last: Int
    orderBy: [TrajectoryOrderByInput!]
    where: TrajectoryWhereInput
  ): [Trajectory!]!
  allWeathers(
    after: WeatherWhereUniqueInput
    before: WeatherWhereUniqueInput
    first: Int
    last: Int
    orderBy: [WeatherOrderByInput!]
    where: WeatherWhereInput
  ): [Weather!]!
  cameraById(where: CameraWhereUniqueInput!): Camera
  counterById(where: CounterWhereUniqueInput!): Counter

  """
  Get all counters from a specific camera
  """
  countersByCameraId(
    """
    The id (Int) of the camera
    """
    cameraId: Int!
  ): [Counter!]
  detectionById(where: DetectionWhereUniqueInput!): Detection
  detectionTypeById(where: DetectionTypeWhereUniqueInput!): DetectionType
  lightningConditionById(
    where: LightningConditionWhereUniqueInput!
  ): LightningCondition
  me: User
  trajectoryById(where: TrajectoryWhereUniqueInput!): Trajectory
  weatherById(where: WeatherWhereUniqueInput!): Weather
}

enum SortOrder {
  asc
  desc
}

input StringFilter {
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  not: NestedStringFilter
  notIn: [String!]
  startsWith: String
}

input StringNullableFilter {
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  not: NestedStringNullableFilter
  notIn: [String!]
  startsWith: String
}

type Trajectory {
  camera: Camera!
  cameraId: Int!
  detectionType: DetectionType!
  detectionTypeId: Int!
  end: DateTime!
  geom: String!
  id: Int!
  start: DateTime!
  trajectory: String!
}

input TrajectoryCreateInput {
  camera: CameraCreateOneWithoutTrajectoriesInput!
  detectionType: DetectionTypeCreateOneWithoutTrajectoriesInput!
  end: DateTime!
  geom: String!
  start: DateTime!
  trajectory: String!
}

input TrajectoryCreateManyWithoutCameraInput {
  connect: [TrajectoryWhereUniqueInput!]
  create: [TrajectoryCreateWithoutCameraInput!]
}

input TrajectoryCreateManyWithoutDetectionTypeInput {
  connect: [TrajectoryWhereUniqueInput!]
  create: [TrajectoryCreateWithoutDetectionTypeInput!]
}

input TrajectoryCreateWithoutCameraInput {
  detectionType: DetectionTypeCreateOneWithoutTrajectoriesInput!
  end: DateTime!
  geom: String!
  start: DateTime!
  trajectory: String!
}

input TrajectoryCreateWithoutDetectionTypeInput {
  camera: CameraCreateOneWithoutTrajectoriesInput!
  end: DateTime!
  geom: String!
  start: DateTime!
  trajectory: String!
}

input TrajectoryListRelationFilter {
  every: TrajectoryWhereInput
  none: TrajectoryWhereInput
  some: TrajectoryWhereInput
}

input TrajectoryOrderByInput {
  cameraId: SortOrder
  detectionTypeId: SortOrder
  end: SortOrder
  geom: SortOrder
  id: SortOrder
  start: SortOrder
  trajectory: SortOrder
}

input TrajectoryWhereInput {
  AND: [TrajectoryWhereInput!]
  camera: CameraWhereInput
  cameraId: IntFilter
  detectionType: DetectionTypeWhereInput
  detectionTypeId: IntFilter
  end: DateTimeFilter
  geom: StringFilter
  id: IntFilter
  NOT: [TrajectoryWhereInput!]
  OR: [TrajectoryWhereInput!]
  start: DateTimeFilter
  trajectory: StringFilter
}

input TrajectoryWhereUniqueInput {
  id: Int
}

type User {
  email: String!
  id: Int!
  name: String
  password: String!
}

type Weather {
  camera: Camera!
  cameraId: Int!
  cloudCoverage: Float
  humidity: Float
  id: Int!
  pressure: Float
  rain: Float
  recordedAt: DateTime!
  temperature: Float
  wind: Float
  windDirection: Float
}

input WeatherCreateInput {
  camera: CameraCreateOneWithoutWeathersInput!
  cloudCoverage: Float
  createdAt: DateTime
  humidity: Float
  pressure: Float
  rain: Float
  recordedAt: DateTime!
  temperature: Float
  wind: Float
  windDirection: Float
}

input WeatherCreateManyWithoutCameraInput {
  connect: [WeatherWhereUniqueInput!]
  create: [WeatherCreateWithoutCameraInput!]
}

input WeatherCreateWithoutCameraInput {
  cloudCoverage: Float
  createdAt: DateTime
  humidity: Float
  pressure: Float
  rain: Float
  recordedAt: DateTime!
  temperature: Float
  wind: Float
  windDirection: Float
}

input WeatherListRelationFilter {
  every: WeatherWhereInput
  none: WeatherWhereInput
  some: WeatherWhereInput
}

input WeatherOrderByInput {
  cameraId: SortOrder
  cloudCoverage: SortOrder
  createdAt: SortOrder
  humidity: SortOrder
  id: SortOrder
  pressure: SortOrder
  rain: SortOrder
  recordedAt: SortOrder
  temperature: SortOrder
  wind: SortOrder
  windDirection: SortOrder
}

input WeatherWhereInput {
  AND: [WeatherWhereInput!]
  camera: CameraWhereInput
  cameraId: IntFilter
  cloudCoverage: FloatNullableFilter
  createdAt: DateTimeFilter
  humidity: FloatNullableFilter
  id: IntFilter
  NOT: [WeatherWhereInput!]
  OR: [WeatherWhereInput!]
  pressure: FloatNullableFilter
  rain: FloatNullableFilter
  recordedAt: DateTimeFilter
  temperature: FloatNullableFilter
  wind: FloatNullableFilter
  windDirection: FloatNullableFilter
}

input WeatherWhereUniqueInput {
  id: Int
}
